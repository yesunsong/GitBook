# 加载和切换场景

在 Cocos Creator 中，我们使用场景文件名（不包含扩展名）来索引指代场景。并通过以下接口进行加载和切换操作：

```js
cc.director.loadScene("MyScene");
```

传入参数是场景的文件名的字符串，无扩展名。如果之前有别的已加载场景，新场 景会替代已加载场景。新场景中的节点将会逐个进入激活状态，节点上的组件也会依次 进人激活状态。旧场景的节点及其对应组件将进入非激活状态并在合适的时机从内存中清理。



## 通过常驻节点进行场景资源管理和参数传递

**常驻节点**:常驻节点是在场景切换时不会被销毁的节点，它会从旧场景中被拿出来放到新场景，默认放置到根节点。由千它默认不在画布中，所以不适合做渲染，但是它常驻内存的特性十分适合传递数据。

引擎同时只会运行一个场景，当切换场景时，默认会将场景内所有节点和其他实例销毁。如果我们需要用一个组件控制所有场景的加载，或在场景之间传递参数数据，就需要将该组件所在节点标记为「**常驻节点**」，使它在场景切换时不被自动销毁，常驻内存。我们使用以下接口：

```js
cc.game.addPersistRootNode(myNode);
```

上面的接口会将 `myNode` 变为常驻节点，这样挂在上面的组件都可以在场景之间持续作用，我们可以用这样的方法来储存玩家信息，或下一个场景初始化时需要的各种数据。

如果要取消一个节点的常驻属性：

```js
cc.game.removePersistRootNode(myNode);
```

​	<u>*需要注意的是上面的 API 并不会立即销毁指定节点，只是将节点还原为可在场景切换时销毁的节点。*</u>



### 使用全局变量

除此之外，简单的数值类数据传递也可以使用全局变量的方式进行，详见 [通过全局变量访问](https://docs.cocos.com/creator/manual/zh/scripting/access-node-component.html#global_variable)。



## 场景加载回调

加载场景时，可以附加一个参数用来指定场景加载后的回调函数：

```
cc.director.loadScene("MyScene", onSceneLaunched);
```

上一行里 `onSceneLaunched` 就是声明在本脚本中的一个回调函数，在场景加载后可以用来进一步的进行初始化或数据传递的操作。

由于回调函数只能写在本脚本中，所以场景加载回调通常用来配合常驻节点，在常驻节点上挂载的脚本中使用。



## 预加载场景

`cc.director.loadScene` 会在加载场景之后自动切换运行新场景，有些时候我们需要在后台静默加载新场景，并在加载完成后手动进行切换。那就可以预先使用 `preloadScene` 接口对场景进行预加载：

```js
cc.director.preloadScene("table", function () {
    cc.log("Next scene preloaded");
});
```

之后在合适的时间调用 `loadScene`，就可以真正切换场景。

```js
cc.director.loadScene("table");
```

就算预加载还没完成，你也可以直接调用 `cc.director.loadScene`，预加载完成后场景就会启动。实战例子可以参考 [21点演示项目](https://github.com/cocos-creator/tutorial-blackjack/blob/master/assets/scripts/Menu.js#L12-L14)

场景切换会等场景加载完成后运行，如果场景预加载并没有完成会继续加载， 直至加载完成后再进行场景切换。在加载过程中原场景会正常工作，包括update、 动画、事件响应等。

**注意** 使用预加载场景资源配合 `runScene` 的方式进行预加载场景的方法已被废除：

```js
// 请不要再使用下面的方法预加载场景!
cc.loader.loadRes('MyScene.fire', function(err, res) {
    cc.director.runScene(res.scene); 
});
```

------

继续前往 [获取和加载资源](https://docs.cocos.com/creator/manual/zh/scripting/load-assets.html) 说明文档。