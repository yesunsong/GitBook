# 第4章　图解指针

指针对于C/C++初学者，以及Java、Action Script、C#等语言转C/C++的程序员而言，是一个比较大的障碍，因为指针非常容易出问题。所以本章会用一种容易理解的方式来介绍指针，相信通过本章的学习，可以让读者对指针有深刻的理解。本章主要介绍以下内容：

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707155237.jpeg)　指针与内存。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707155237.jpeg)　指针操作。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707155237.jpeg)　指针与数组。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707155237.jpeg)　函数指针。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707155237.jpeg)　野指针和内存泄漏。

## 4.1　指针与内存

首先，指针是一种变量，这个变量存储的内容是一个地址，每一个变量在内存中都会占用一定的空间，指针变量也不例外，变量可以在其所在的空间内存储数据。每个变量在内存中都会有一个地址，来标记变量在内存空间中的位置（这里假定环境是在32位系统下）。

下面我们来定义一个int*指针，以及一个int变量，int变量的值为100，int*指针指向int变量：

```
int* p;
int a = 100;
p = &a;
```

从图4-1中可以看到这两个变量在内存中的位置，每个变量都是占4个字节，第一个是指针变量，变量中存储的内容是0x04这个值，也就是a的地址，而a存储的内容则是100这个数值。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707155238.jpeg)

图4-1　指针在内存中的表现

**从内存的角度看，指针实际上和一个int没有太大差别，本质上都是在内存中记录数据**。但从语法上看，指针可以进行更加丰富的操作（如解引用，->操作）。

在游戏中创建的任何对象都是放在内存中的，除了可以用变量名来操作它们，还可以用指针来操作，**通过将指针指向想要操作的内存，就可以对这块内存进行操作**（释放、读取、修改），如果操作的是一块**不可被操作的内存**，那么程序就会崩溃。

```
//char类型变量c的值为'a'
char c = 'a';
//指针pc指向c的地址
char* pc = &c;
//将指针pc指向的内容修改为'b'
*pc = 'b';
//打印出的内容为 b
printf("%c", c);
```

一个指针包含指针的类型，指针指向对象的类型，指针指向对象的内存区，以及指针所占的内存区。代码中的pc指针是一个char*类型的指针，指向一个char类型的对象，其指向的内存区是变量c所在的内存地址，而pc指针本身占用一个4字节大小的空间，**任何指针，本质都是存储地址**，不因指针类型而改变。

指针的类型限定了这个指针可以做的操作，以及这个指针做这个操作的效果。指针指向对象的类型本身没有重大意义，因为指针实际上可以指向任何对象，不同类型的对象只要做一个强制转换即可，将一个类型指针转换为另外一个类型的指针时，需要谨慎。

指针指向对象的内存区是指向对象在内存中的偏移地址，在这块地址存放了这块对象的内容，是可以操作的内存区，这需要小心操作，一旦操作错误，修改了相临的内存区，很可能出现意外的错误。

指针所占的内存区，是一块32位的内存，相当于一个int，这块内存存放了指向对象的地址，当把指针指向另外一个内存时，相当于修改了这个int的值。

将char* pc = &c修改为下面两行代码，编译运行后，结果是一样的。

```
int* i = reinterpret_cast<int*>(&c);
char* pc = reinterpret_cast<char*>(i);
```

接下来给大家带来一个非常经典的问题，const 指针和指向const对象的指针，以及指向const对象的const指针，听起来像是绕口令，但面试的时候这道题还是经常出现的。

```
const char* p1;
char* const p2;
const char* const p3;
```

*号前面的是指针的类型，*号后面是对指针的修饰，指向const char*的指针内容不能被修改，而const指针一旦指向某块内存，就不能重新指向另外一块内存，就相当于const int的值不能变。

再来一个问题，下面两个指针，哪个是const指针？哪个是指向const对象的指针？可以看到，*号后面没有带任何修饰符，所以这两个都是指向const对象的指针。碰到类似这样的问题，只需要根据*所在的位置来判断即可。

```
const char* p1;
char const* p2;
```

在64位的操作系统下，int占64位，8个字节，但为什么sizeof(int)打印出来的数据会是4个字节呢？因为编译器生成的是32位的应用程序，而64位操作系统可以兼容32位应用程序。如果希望打印出来的是8个字节，只需要让编译器编译64位的程序即可，在VS下，可以在解决方案的平台设置中，设置目标平台为64位。

## 4.2　指针操作

指针的操作有基本操作及和指针类型挂钩的操作，当指向某个类的时候，可以用箭头操作符（->）来操作对象的成员变量和成员函数，这些称为对指向对象的操作，效果等同于对象变量、变量或方法。

指针的基本操作有：*解引用、算数运算操作+、-、++、--、分配和释放new、delete，以及赋值操作符=、判断操作符==、!=。

解引用的效果相当于把指针变成对象来用，在解引用的情况下，操作的仍然是同一块内存。在第一个例子中，就是用了解引用来对指针指向的内存进行赋值。

而+、-、++、--都是对指针进行偏移，也就是修改指针指向的地址，把指针当成一个int对象的话，就是直接修改这个int对象的值。++和--对应的操作单位都是1，但是**1单位的偏移量是多少？这是根据指针类型来定的**！平时我们接触最多的就是char*，char*的移动单位是一个字节，初学的人很容易误以为，不管是什么类型的指针，做这些算数操作都是按照一个字节来移动的，但这种理解是错误的。1单位移动的字节数，是根据*号前面的数据类型所占字节来的计算的。

```
//移动单位1个字节 sizeof(char)
char* p1;
//移动单位4个字节 sizeof(int)
int* p2;
//移动单位8个字节 sizeof(double)
double* p3;
```

指针的赋值是将指针指向的地址赋给另外一个指针，结果是这两个指针指向同一个对象，而这块内存并没有发生变化，当这块内存被释放的时候，访问就会报错。

当希望复制、保存这个对象的时候，需要另外分配一块内存，然后填充这块内存，如使用memcpy函数，又如*p1 = *p2（这种操作当指向的是类对象时，会有一些问题，就是在类设计得较复杂时，需要重写类的=操作符）。

假设这个指针是new出来的，那么一定要通过delete来释放，而new [] 对应的则是delete [] 操作。

## 4.3　指针与数组

在C/C++中，数组是一块连续的内存，而且和指针的关系非常密切，一般我们指针的算术操作都是应用在数组中。

```
int a[] = { 1, 2, 3, 4 };
int* pa = a;
int* pb = &a[0];
```

将上面的a、pa、pb这3个地址打印出来，会发现它们的地址都是一样的，都指向数组a的首地址，上面的代码首先初始化了一个拥有4个元素的数组，这种写法，已经固定分配了大小为4个int的内存，不可以存入第5个元素了。

可以通过a[1]，a[2] 这种下标操作来取出元素，也可以通过*(pa + 1)，*(pa + 2)来取出，同时也可以直接操作 *(a + 1)，因为数组本身就是一个指针，不同的是，当用sizeof操作符来求a的长度时，返回的是数组的大小4*4，而求pa或pb的时候，返回的是4。

二维数组和指向指针的指针用得比较少，这里也简单介绍一下。

```
int b[2][4] = { 0, 1, 2, 3, 4, 5, 6, 7 };
```

上面的数组b是一个2列4行的数组，其中包含了8个元素，可以理解为b由两个长度为4的数组组成，这时b不等于int*，b是二级指针，int**，当用*b将b求解出来的时候，打印后会发现这是第一个数组的地址，而**b才能解析出数组的第一个元素。

对这个二维数组赋值的顺序是先将第一个数组的4个int填满，再填充第二个数组，在内存中的显示如图4-2所示。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707155239.jpeg)

图4-2　二维数组

那么使用二级指针b如何来获取数组中的元素呢？

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707155237.jpeg)　**b取出第1个数组中的第1个元素。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707155237.jpeg)　**(b + 1) 取出第2个数组中的第1个元素。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707155237.jpeg)　*(*b + 1) 取出第1个数组中的第2个元素。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707155237.jpeg)　*(*(b + 1) + 1) 取出第2个数组中的第2个元素。

而用int* p来指向b，可以用p来取出二维数组中的所有元素，*p 取出第1个数组中的第1个元素，*(p + 4)取出第2个数组中的第1个元素。

## 4.4　函数指针

函数指针指向一个函数的地址，通过函数指针可以调用函数，而在Cocos2d-x中的回调函数，就是用了函数指针来实现的。下面先来看一个简单的例子。

```
//Log函数
void Log(const char* msg)
{
    printf("%s\n", msg);
}
//赋值函数指针fun
void (*fun)(const char*)= Log;
//执行函数指针
(*fun)("abc");
```

上面的代码简单地展示了函数指针的使用，首先声明一个函数指针fun，然后让该函数指针指向Log函数，最后使用函数指针来调用Log函数，这里只要知道函数指针怎么写就可以了。通过对比Log函数可以发现，它们只有一点不同，就是Log换成了(*fun)。这种写法是定义了一个变量，变量的名字是fun，而变量的类型是void (*)(const char*)，可以将符合该函数原型的任意函数赋值给它，然后调用这个函数，例如，注册一个回调函数，在接收到服务端发送的数据时，调用该回调函数进行处理，在不同的情况下可以注册不同的回调函数，而不需要在调用的地方写一大堆代码。

前面介绍的是普通函数的写法，平时用得较多的还是类的成员函数。类的成员函数与普通函数是不一样的写法，因为成员函数比普通函数多了对象的概念，可以在成员函数里使用this指针，如果没有this指针则不行。

```
class A
{
public:
    void Log(const char* msg)
    {
        printf("%s\n", msg);
    }
};
 //定义fun成员函数变量
void (A::*fun)(const char*) = &A::Log;
//创建一个A对象
A aa;
//执行成员函数
(aa.*fun)("a");
(&aa->*fun)("b");
```

上面的代码定义了一个类A，该类有一个public的成员函数Log，首先定义了一个A的成员函数指针fun，注意这里的写法与前面的普通函数不同，在*fun前面加A::表示这个函数是A的成员函数，然后再定义函数的原型，并将A::Log的地址赋给它，这时fun指向的是A::Log的地址。但这还不够，还需要一个对象，所以接下来定义了一个对象a。

与普通函数调用不同的是*fun前面对应加了这个对象，切记看清楚括号的范围，忘记加括号或者括号弄错，则将编译不过。在这里既可以使用对象、方法来调用成员函数指针，也可以用指针->来访问。

## 4.5　野指针和内存泄漏

野指针和内存泄漏是使用指针的时候较容易出现的问题，野指针是指指向垃圾内存的无效指针，而内存泄漏则主要是指在堆上面新建出来的内存没有被释放。

当声明了一个指针，但并不打算为指针赋值时，应该把指针初始化为NULL，否则指针会指向一个随机的地址。

当将一个新建出来的指针删掉之后，则指向的这块内存也无效，因此应该把它设置为NULL。

如果将一个函数的局部变量的地址返回给指针，那么这块地址也是无效的。

对这些指针进行操作是非常危险的，一般程序员在使用指针的时候，会在前面加上是否NULL的判断，加上该判断之后会感觉很有“安全感”，但是野指针可以直接渗透进来，并对程序造成致命性的打击。

相对野指针，内存泄漏就隐蔽多了。不管是在编译中还是在运行中，都很难发现明显的问题，但假设内存泄漏的地方被重复执行，时间久了就会耗尽内存。这种问题一般在服务端程序中会较严重一些，因为服务器需要长时间运行。在PC客户端上这个问题不算严重，但是在手机上，虽然现在硬件发展很快，但是大部分手机的内存还是比较小的，特别是在一些老爷机上，稍微多一点的内存泄漏就可以使系统崩溃，所以，应小心维护好在堆上面分配的内存 。

曾经有个朋友写了这样一个函数，在函数的开始新建了一块内存，然后在函数返回之前，删掉它，这个代码本身没有内存泄漏，之后，他在维护这份代码的过程中，向其中加了一些错误判断，如果发生错误，返回什么，相信很多人都写过这样的代码，但他在添加这些代码时，所有的返回语句都忘记把这块内存删掉了，所以内存在缓慢地增长着。

要检测内存泄漏，可以通过一些内存泄漏检测工具来做，这里介绍一个老方法，就是在对象的构造函数和析构函数中来统计，创建了多少对象，释放了多少对象，程序运行结束后查看日志，就可以发现是否有内存泄漏了。

```
//定义静态变量
static int gGameObjectCount = 0;
 //构造函数打印统计
CGameObject::CGameObject(void)
{
    CCLog("CGameObject count %d", ++gGameObjectCount);
}
 //析构函数打印统计
CGameObject::～CGameObject(void)
{
    CCLog("～CGameObject count %d", --gGameObjectCount);
}
```