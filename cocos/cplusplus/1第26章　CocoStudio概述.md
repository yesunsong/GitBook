# 第26章　CocoStudio概述

本章作为CocoStudio工具链的开篇，会简单介绍CocoStudio的结构以及用法，使大家对CocoStudio有个整体的认识，并大致介绍各个版本的CocoStudio，以及CocoStudio与Cocos2d-x引擎的版本对应关系。本章主要介绍以下内容：

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　CocoStudio是什么？

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　CocoStudio的设计目标。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　使用CocoStudio。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　管理资源。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　版本对应。

## 26.1　CocoStudio是什么

CocoStudio是触控开发的一套基于Cocos2d-x的免费工具集，拥有UI、动画、场景、数据编辑等功能，目的是提高Cocos2d-x游戏的开发效率，可以在CocoStudio的官网下载http://www.cocos.com。

因为是官方推出的开发工具，所以CocoStudio的更新维护得到了保障，从一开始的看上去美好，用起来不得不吐槽，到现在还不算完善的版本，其进步之大是有目共睹的。虽然目前的CocoStudio还没有达到一个优秀编辑工具所应有的体验，但其一直在进步。

以Cocos2d-x游戏开发为核心，将大量实用的功能整合到工具集中，是个不错的设想。先把整个编辑器的框架搭好，然后设计良好的扩展接口，开放API或者开源CocoStudio的代码，利用群众的力量为CocoStudio贡献各种各样的插件，甚至集成新的工具。

免费和开源带来的更多可能是索取而不是贡献，通过搭建一个在线商店平台，售卖插件和工具，可以大大激励人们开发优秀的插件和工具。在线商店既然提供了插件、工具，同样也可以贩卖音效，动画、图片、UI、模型等资源。如果这样发展下去，CocoStudio应该为成为一个类似Unity的开发工具（在发布的CocoStudio 2.1版本中果然开始集成了插件下载，商店之类的内容，但与Unity的插件和商店比起来，仍有巨大的差距，商店内容的丰富程度、规范和质量都有待提高。制定一系列严格的规范，再通过一些比赛活动，可以有效缓和这一问题）。

在2014年的十月底，CocoStduio 2.0发布了，所有的编辑器都合并在一起，整合和分离各有各的好处，分离的好处是每个工具更独立、专注。整合的好处则是管理，操作的时候会更方便。CocoStduio 2.0的升级带来了更加流畅的体验，整体界面重构之后，看上去舒服了很多，操作起来也流畅了不少。可以一键发布项目到Cocos Code IDE、Xcode、VS中。

CocoStduio 2.0出来后笔者马上试用了一下，触控做的东西让人又爱又恨，界面让人耳目一新，比之前的版本漂亮很多，但问题也较多。首先，有很多机器“跑”不起来，装完之后可能需要重启，并且需要以管理员身份运行。当然，这个问题在后面的版本中很快就被修复了。其次，很多功能都被移除了。一些被移除的功能还是蛮实用的（如动画对象的动画名，不过最新版本已经恢复了这个功能）。另外，只能生成.csb文件，并且生成的.csb文件以原先的方式加载还会报错，因为2.x版本还无法完全取代1.6版本，所以在这段尴尬的时间里，1.6和2.0两个版本的功能是并存的。新版本的CocoStudio解析格式与旧版本的并不兼容，因为改动太大了，所以只能使用另外的接口来加载2.x生成的.csb文件。

## 26.2　CocoStudio的设计目标

在官方的定义中，Cocos Studio把适用于美术、策划的工具完全分开， 分为UI编辑器、动画编辑器、场景编辑器、数据编辑器， 这4个编辑器分别为UI美术、动作美术、策划、数值策划量身定做。

看上去好像没程序什么事了，但别忘了，这套工具集是围绕Cocos2d-x来转的，也就是策划和美术围着程序员转。工具集本身将很多程序所需要的编码转换成美术和策划的工作，CocoStudio在一定程度上简化了程序员的工作，将原本需要修改代码才能完成的工作分离出来，通过操作CocoStudio也可以完成修改，提高开发效率。

CocoStudio是一套多人协作的工具集，每个工具定位清晰、分工明确，需要划分好职责，规范操作，才能减少游戏开发过程中的内耗。这里的内耗包括程序、美术、策划之间过高的沟通成本，由于某一方延期导致其他人处于空闲状态的成本浪费，资源和需求的修改导致一些重复或无用的工作。

其实不论什么工具，只要能形成流水线的协作就可以，并不一定要“穿套装”，包揽整条流水线。如果使用套装的工作效率并没有得到很大的提高，那么还不如不用。就如数据编辑器的数据编辑功能远远比不上Excel，有时需要做的可能是一个解析Excel表格的库，或者将Excel表格转换为.json文件格式的工具，而不是一个编辑.json文件的工具。

而从CocoStudio2.0开始，推翻了原先的设计目标，只保留了部分最有用的功能，并整合进了Cocos，将Cocos2d-x的2d-x后缀去掉，一方面表明了Cocos并不仅仅可以用来制作2D游戏，另一方面通过将Cocos引擎下所有的产品进行整合，成为游戏开发一站式解决方案，整合了从项目创建、开发、资源管理、界面编辑，到最后的发布一系列流程，从而提高游戏开发的效率。

## 26.3　使用CocoStudio

那么如何使用CocoStudio来提高开发效率呢？首先需要认识清楚每个编辑器的作用，制定编辑器的多人协作规范（命名规范，设计规范），根据实际情况来选择性地使用工具（例如开发流程阻塞在美术设计环节，那么UI编辑器可以由程序员或策划人员来进行操作和维护，如果游戏逻辑过于复杂且场景多为动态生成，则场景编辑器可以弃用），在工具中按F1按键可以查阅官方的帮助文档：

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　1.x版本的帮助文档是http://upyun.cocimg.com/CocoStudio/helpdoc/ v1.0.0.0/zh/ index.html。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　2.x版本的帮助文档是http://www.cocos.com/tutorial/index.html。

### 26.3.1　使用UI编辑器

UI编辑器的目的是让程序员摆脱代码中的UI坐标编码，一个一个地编写坐标编码不仅痛苦，且难以维护，开发效率极低，而UI的位置摆放是美术人员擅长的事情，所见即所得的UI编辑可以大大提高开发效率。

UI编辑器的工作流程应该是这样的，策划输出UI的需求（整个UI是什么样的，UI提供怎样的功能？绑定哪些数据？UI节点的**命名规则和Tag分配原则，UI规格尺寸的需求**），拿到这样一份需求，美术人员开始画图，并执行拼凑界面的工作。如果需求不清晰，规范没定义，美术人员就开始执行，后面必然是要返工的。在这里需要按照项目所要求的标准分辨率为准进行制作，这个分辨率的制定取决于目标平台，以及不同分辨率下的适配规则。

画完图之后开始在UI编辑器里拼凑，拼凑的时候，需要创建一个节点树，如果这个时候没有定义节点树的规范的话，那么美术人员输出的很可能是所有UI全部放在Panel下，这个是很不合理的，这个节点树的结构设计其实也是UI面板的结构设计，最好由策划人员来设计，然后程序员进行审核，作为策划人员，对程序使用的引擎有一些基本了解是非常有用的，知道哪些能做，哪些不能做，知道程序是怎样实现的，这样对游戏的策划有巨大的帮助。节点树系统是策划人员应该了解的。之所以要程序员来审核，是为了确保策划人员设计的结构合理，如果设计不合理的话，会导致一些需求难以实现，例如两个节点是父子节点关系，而有需求是干掉父节点保留子节点，那么这个父子节点结构就不合理了。美术人员在摆放的时候还需要注意九宫和布局的问题。

节点的命名规则和Tag的分配原则需要一开始确定好，这个规则可以是程序员来制定，因为程序员这些规则，是方便程序使用的（往往是跟一些枚举对应）。程序在使用UI编辑器输出文件时，往往还需要做数据绑定、初始化显示内容等工作，以及一些动态创建的内容，这些都需要建立在良好的节点结构以及规范的命名条件下。如果项目中已经使用了CocosBuilder，那么CocoStudio也是可以兼容的，可以直接导入.ccb文件，但会丢失一些东西。

### 26.3.2　使用动画编辑器

使用动画编辑器可以编辑骨骼动画和帧动画，使用动画编辑器可以享受引擎提供的一系列骨骼动画的API（这里的骨骼动画也支持帧动画），动画编辑器则完全是美术人员的工具。程序员只需要直接使用美术人员导出的动画就可以了。这里的**动画名称、骨骼名称**，以及一些挂载点骨骼（例如武器的挂载点，人物一开始可以没有武器，但装备上武器之后，就需要在人物的手上能够正确显示），需要形成规范同需求一起交给美术人员。

CocoStudio虽然可以编辑骨骼动画，但是据一些美术人员反映，CocoStudio的动画编辑器用起来并不顺手，在操作体验各方面和Flash与Spine相比还有些差距，并且美术人员对一个工具掌握的熟练度是非常影响开发效率的，所以动画编辑器也支持导入Flash和DragoneBones动画。

使用DragoneBones可以编辑嵌套骨骼动画，在TestCpp中，Test Armature Nesting就是使用DragoneBones的嵌套骨骼动画实现的，在例子中各种武器的切换非常平滑、协调，DragoneBones导出的Plist、PNG和XML可以直接用于创建动画对象，而Flash则需要导出fla，然后在动画编辑器中重新导出为.json或.csb文件格式。

制作Flash项目时，需要注意以下几个问题，具体可以查看官方论坛：http://www. cocoachina.com/bbs/read.php?tid=169621。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　Flash版本应该为CS 6.0，低版本不提供支持。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　新建Flash项目的时候应该选择ActionScript 3.0。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　动画中只有两种元素，一个是“元件”，另一个是“图形”。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　所有的图形必须是位图，暂时不提供包含矢量图的fla文件导入，在保存项目之前需要将所有的矢量图转换为位图。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　每一个骨骼对应一个“元件”，创建元件时可以选择影片剪辑和图像两个类型。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　每一个元件对应一个贴图，不能一个元件中放多个贴图。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　目前除了整个人物（或者说整个项目）可以由多个元件组成外，其他均不能有多个元件嵌套。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　每个项目只能有一个场景，并且这个场景只有一个精灵（或者说人物）。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　不要修改锚点属性，不要使用斜切。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　给人物设置帧动画的时候，必须将最上面的图层设置为一个空的图层，并给每一个关键帧设置动画的名称。

![img](https://gitee.com/nlpleaf/PicGo/raw/master/20200707160429.jpeg)　当整个元件制作完成时必须将该元件加入到主场景中。

### 26.3.3　使用数据编辑器

数据编辑器本质上讲只是一个Excel表格到.json文件的格式转换工具。说起对数据的编辑，在Excel里编辑数据是最快的，各种公式、批量操作是数据编辑器无法比拟的。之所以说数据编辑器是个转换工具，是因为其需要依赖于Excel输出的表格，而不是在编辑器中创建数据文件。输入Excel表格，输出.json文件，虽然提供编辑功能，但如果需要编辑数据的话，多数策划人员肯定是选择在Excel里而不是数据编辑器。

虽然没有Excel编辑数据快，但数据编辑器并非一无是处。数据编辑器输出的.json文件可以用于程序加载（引擎提供了解析方法），也可以用于场景编辑器中的自定义属性组件中，如果游戏以场景编辑器为主，所有的逻辑都以场景编辑器的触发器形式调用，数据编辑器导出的数据文件结合自定义属性组件就成了标配。

### 26.3.4　使用场景编辑器

场景编辑器用于编辑场景，场景的定义比较大，在这里可以理解为游戏的背景、地图、UI、动画、声音、特效、逻辑等元素的组合，并不仅仅是一个容器。

场景编辑器是用于整合所有资源的一个编辑器，在这里场景编辑器的定位过于大，功能相对复杂，职责也不单一，而且稳定性也不够好，作为一个面向策划人员的编辑工具，不少策划人员表示难以完全驾驭。

除了UI和动画，场景中更多的是逻辑，是动态生成的对象，而不是摆放上去的对象。所以在这里场景编辑器的使用更倾向于给策划人员一个预览大概效果的测试场景编辑器，以及一些可以完全由策划控制的内容编辑，例如游戏的剧情过度场景等。如果在这里没有划分清楚程序员和策划人员的职责，那么后面会变得混乱而难以管理。

场景编辑器可以做很多事情，但只需要让其专注做某一件事情就足够了。职责越多，问题越多！场景编辑器是一个需要慎用的编辑器，UI和动画编辑器都有明确的职责，而编辑场景，则难一言以蔽之，在一些只有一个场景的游戏中，编辑场景等于编辑游戏。如果不是有很合适交给场景编辑器做的事情（测试、新手引导、剧情等算是合适的事情），那么就不要轻易使用场景编辑器。一旦使用，就要有效果，例如用编辑器来做开发会提高效率，编码会减少，或者这部分内容的可维护性大大提高等。

什么情况下使用场景编辑器？要看其能带来什么好处，UI和动画编辑器带来的好处是很清晰、明显的。而场景编辑器带来的好处，需要开发者自己去把控。

### 26.3.5　使用CocoStudio 2.x

CocoStudio 2.x主要用于**摆放**场景和UI，可以制作简单的动画，绑定代码中的回调或者自定义类，能够方便地发布资源到工程项目。

CocoStudio 2.x没有场景和UI的区分，摒弃了类似场景触发器这样鸡肋的功能，专注于界面操作体验，与Cocos2d-x很好地互补，能够很方便地嵌套层、节点与场景，大大提高了编辑时的自由度。

## 26.4　管理资源

由CocoStudio工具集导出的各种各样的资源可能是凌乱的，如何整合、管理，快速地在游戏中使用这些资源，需要一个规划。资源组织不当带来的后果是，程序加载资源时出现各种路径错误，或者资源冗余重复，或者资源丢失之类的问题。

首先资源目录需要划分好、归类好，用一个命名规则来保证所有资源的文件名都不重复。文件名重复可能导致的问题是，使用Plist图集时，一些同名的资源会丢失。因为加载Plist图集是将图集中所有的小图片放置到引擎的缓存里，在缓存中按照小图的文件名作为key来管理的，如果加载了多个Plist，而Plist里有重名的文件，那么该文件会被覆盖（使用多个Plist来做帧动画，而图片名字都一样时，会导致所有的动画都是一样的）。

资源规划好之后，在开始编辑UI、动画之前，应该先将需要复用的资源打包Plist。在编辑UI和动画时，是允许使用多张Plist的，但Plist的规划需要合理，尽量不造成只用到图集中很小的一块图片，就将整个Plist加载进来的这种情况。将复用的资源打包到Plist中可以避免因为CocoStudio的自动合并图集而导致资源的冗余。

在资源面板中，有一个Resource目录（2.x版本是res目录），它是资源目录，在这里将其称之为输入目录。使用其中的资源进行编辑时，尽量保证不同项目的输入目录是同一个目录，这样方便资源的整理和重用。在导出项目时，会输出到另外一个资源目录，这里称之为输出资源目录。在该目录下会生成一个或多个以项目名称命名的.json文件，资源的路径并不是相对于Resources文件夹的路径，而是**相对于导出.json配置文件的路径**。

输入资源目录和输出资源目录有3点区别，动态生成的.json/.csb文件都将在输出目录中，输出目录可能会将输入目录的碎图打包成图集，只有项目中使用到的资源才会被输出，以避免没用到的冗余资源。

输出目录应该放在项目下的Resource目录下（2.x版本是res目录），如果需要在Resource目录下需要新建子目录来存放输出目录，那么应该把这个相对路径（自己新建的目录结构相对Resource目录的相对路径）添加到引擎的搜索路径中（FileUtils::getInstance()->setSearchPaths）。

CocoStudio 1.3之后，新的资源管理可以在场景编辑器中自动整合，可以将编辑的多个UI、动画项目的资源整合到一起，以游戏为单位输出资源，并自动将资源进行归类等。如果仅仅是使用动画编辑器或UI编辑器，可以按照前面的介绍来管理资源。CocoStudio 2.0开始则不需要担心这个问题，因为只有一个编辑器，直接编辑好发布资源即可。输出目录被生成到CocoStudio项目的res目录下。2.x还可以直接生成程序工程项目。

另外，在使用CocoStudio 2.x来编辑内容的时候，所引用的资源是基于内容文件的相对路径，例如，编辑一个节点文件，引用到了其他目录的资源，当然，这些目录是在项目的资源目录下，导出的时候，会导出所有关联到的文件，并保持目录树的结构，这时如果再对导出的目录进行调整，那么就可能出现资源丢失的情况。对于目录结构，最好是保证输入和输出的目录结构一致，所以需要规范目录结构的话，最好在CocoStudio制作的时候就将目录结构规范好。

另外一种会导致资源丢失的原因是引用了一个Plist图集，在修改Plist图集中图片的名字后，没有重新导出这个节点文件，因此就会找不到该张图片。当然，如果使用一键发布，会重新生成节点资源文件。

## 26.5　版本对应

Cocos2d-x的升级向来不大喜欢考虑对旧版本的兼容，各种接口变来变去让人头疼，这也是很多人不管新版本出来多少，还抱着旧版本不愿升级的原因。除非碰到一些BUG需要升级到新版本才能解决或新版本引入了诱人的特性，否则不轻易升级，升级完引擎之后，往往需要花一段时间编译通过才能运行起来。CocoStudio的版本问题也类似。

Cocos2d-x和CocoStudio的版本也需要一一对应，如果不对应可能会出现错误。例如不兼容.csb格式的文件，.json文件的一些新字段解析不到，一些旧字段消失了等。Coco- Studio 1.0之前的版本就不介绍了，下面介绍1.x版本1.x版本从1.1到1.6的版本对应如表26-1所示。

**表26-1　CocoStudio1.x与Cocos2d-x版本对应表**

| **CocosStudio版本** | **2d-x v3版本** | **2d-x v2版本** | **2d-JS版本** |
| ------------------- | --------------- | --------------- | ------------- |
| 1.6.0.0             | 3.2             | 2.2.5           | 3.1           |
| 1.5.0.1             | 3.2             | 2.2.5           | 3.0 RC2       |
| 1.5.0.0             | 3.0             | 2.2.4           | 3.0 RC2       |
| 1.4.0.1             | 3.0             | 2.2.3           | 3.0 RC2       |
| 1.4.0.0             | 3.0             | 2.2.3           | 3.0 RC2       |
| 1.3.0.1             | 3.0rc1          | 2.2.3           | 3.0 Alpha     |
| 1.3.0.0             | 3.0rc0          | 2.2.3           |               |
| 1.2.0.1             | 3.0beta         | 2.2.2           |               |
| 1.1.0.0             |                 | 2.2.1           |               |
| 1.0.0.2             |                 | 2.2.0           |               |
| 1.0.0.1             |                 |                 |               |
| 1.0.0.0             |                 |                 |               |

后面的版本向下兼容的问题就好很多了，接下来是CocoStudio 2.0。CocoStudio 2.0应该对应Cocos2d-x 3.3RC0，但在加载的时候，需要使用全新的CSLoader来进行加载。2.x版本从2.0到2.1.5的版本对应如表26-2所示，更详细的版本对应问题可以查阅官网论坛：http://www.cocoachina.com/bbs/read.php?tid=182077。

**表26-2　CocoStudio 2.x与Cocos2d-x版本对应表**



| CocosStudio版本                           | 对应Cocos2d-x版本 | JS版本    | 备注                                                         |
| ----------------------------------------- | ----------------- | --------- | ------------------------------------------------------------ |
| v2.1.5  v2.1.2beta  v2.1 (事件:更名Cocos) | v3.4final         | v3.3 rc0+ | Cocos新增JSON格式导出，Cocos2d-JS仅支持此格式                |
| v2.1beta                                  | v3.4beta0         | 不支持    | 已分离出Reader，可以将Reader拉取到其他版本Cocos2d-x，以支持新版本的CocoStudio |
| v2.0.6                                    | v3.3final         | 不支持    |                                                              |
| v2.0.5                                    | v3.3rc2           | 不支持    |                                                              |
| v2.0.2                                    | v3.3rc2           | 不支持    |                                                              |
| v2.0beta0                                 | v3.3rc0           | v3.1      |                                                              |