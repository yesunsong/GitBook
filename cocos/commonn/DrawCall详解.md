DrawCall是CPU对底层图形绘制接口的调用 命令GPU执行渲染操作。渲染流程采用流水线实现，CPU和GPU并行工作，它们之间通过命令缓冲区连接。CPU向其中发送渲染命令，GPU接收并执行对应的渲染命令。

这里DrawCall影响绘制的原因主要是因为每次绘制时，CPU都需要调用DrawCall，而每个DrawCall都需要很多准备工作，检测渲染状态、提交渲染数据、提交渲染状态。而GPU本身具有很强大的计算能力，可以很快就处理完渲染任务。

当过多，CPU就会很多额外开销用于准备工作，CPU本身负载，而这时GPU可能闲置了。

解决DrawCall：过多的DrawCall会造成CPU的性能瓶颈：大量时间消耗在DrawCall准备工作上。很显然的一个优化方向就是：尽量把小的DrawCall合并到一个大的DrawCall中，这就是批处理的思想。下面是一些具体实施方案：

* 合并的网格会在一次渲染任务中进行绘制，他们的渲染数据，渲染状态和shader都是一样的，因此合并的条件至少是：同材质、同贴图、同shader。最好网格顶点格式也一致。render command 相邻，大致可以理解为节点树中顺序相邻、texture 一致、blend function 一致、shader program 一致
* 尽量避免使用大量小的网格，当确实需要时，进行合并。
* 避免使用过多的材质，尽量共享材质。
* 合并本身有消耗，因此尽量在编辑器下进行合并
* 确实需要在运行时合并的，将静态的物体和动态的物体分开合并：静态的合并一次就可以，动态的只要有物体发生变换就要重新合并。



最后，使用图集减少Draw call是有一定前提条件的（像上述条件），图集并不能减少Draw call，材质从哪里来的和glDrawElements次数没关系。

真正减少Draw call是需要多个连续绘制的节点使用同样的贴图时，可以一次性批量绘制。



会打断合并的情况：ttf字体、mask组件